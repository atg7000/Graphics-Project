<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Original</title>

        <!-- Babylon.js -->
        <script src="https://code.jquery.com/pep/0.4.2/pep.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/ammo.js"></script>
        <script src="https://preview.babylonjs.com/cannon.js"></script>
        <script src="https://preview.babylonjs.com/Oimo.js"></script>
        <script src="https://preview.babylonjs.com/libktx.js"></script>
        <script src="https://preview.babylonjs.com/earcut.min.js"></script>
        <script src="https://preview.babylonjs.com/babylon.js"></script>
        <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
        <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        var canvas = document.getElementById("renderCanvas");

        var engine = null;
        var scene = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true }); };
        class Car {
            constructor(scene) {
                this.power = 20;
                this.speed = new BABYLON.Vector3();
                this.maxSpeed = 30;
                this.turnSpeed = 0;
                this.maxTurnSpeed = 2;
                this.turnAcceleration = 40;
                this.lights = [];
                this.body = BABYLON.Mesh.CreateSphere("sphere1", 16, 1, scene);
                this.body.position.y = 0.5;
                this.body.rotationQuaternion = new BABYLON.Quaternion();
                var light = new BABYLON.Mesh("", scene);
                light.position.x = 0.2;
                this.lights.push(light);
                this.body.addChild(light);
                var light = new BABYLON.Mesh("", scene);
                light.position.x = -0.2;
                this.lights.push(light);
                this.body.addChild(light);
            }
            update(inputMap, deltaTime) {
                if (inputMap["w"] || inputMap["ArrowUp"]) {
                    this.speed.z += this.power * deltaTime;
                }
                if (inputMap["s"] || inputMap["ArrowDown"]) {
                    this.speed.set(0, 0, 0);
                }
                if (inputMap["d"] || inputMap["ArrowRight"]) {
                    this.turnSpeed += this.turnAcceleration * deltaTime;
                    this.body.rotationQuaternion.multiplyInPlace(BABYLON.Quaternion.RotationAxis(new BABYLON.Vector3(0, 1, 0), this.turnSpeed * deltaTime));
                }
                if (inputMap["a"] || inputMap["ArrowLeft"]) {
                    this.turnSpeed -= this.turnAcceleration * deltaTime;
                    this.body.rotationQuaternion.multiplyInPlace(BABYLON.Quaternion.RotationAxis(new BABYLON.Vector3(0, 1, 0), this.turnSpeed * deltaTime));
                }
                if (!(inputMap["d"] || inputMap["ArrowRight"]) && !(inputMap["a"] || inputMap["ArrowLeft"])) {
                    this.turnSpeed = 0;
                }
                if (Math.abs(this.turnSpeed) > this.maxTurnSpeed) {
                    this.turnSpeed = BABYLON.Scalar.Sign(this.turnSpeed) * this.maxTurnSpeed;
                }
                if (this.speed.length() > this.maxSpeed) {
                    this.speed.normalize().scaleInPlace(this.maxSpeed);
                }
                var mat = new BABYLON.Matrix();
                this.body.rotationQuaternion.toRotationMatrix(mat);
                this.body.position.addInPlace(BABYLON.Vector3.TransformCoordinates(this.speed.scale(deltaTime), mat));
            }
        }
        class Playground {
            static CreateScene(engine, canvas) {
                // This creates a basic Babylon Scene object (non-mesh)
                var scene = new BABYLON.Scene(engine);
                // This creates and positions a free camera (non-mesh)
                var camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
                // This targets the camera to scene origin
                camera.setTarget(BABYLON.Vector3.Zero());
                // This attaches the camera to the canvas
                camera.attachControl(canvas, true);
                // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
                var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
                // Default intensity is 1. Let's dim the light a small amount
                light.intensity = 0.4;
                var light2 = new BABYLON.PointLight("light1", new BABYLON.Vector3(0, 8, 0), scene);
                light2.intensity = 0.1;
                var light3 = new BABYLON.PointLight("light1", new BABYLON.Vector3(0, 8, 20), scene);
                light3.intensity = 0.1;
                // Our built-in 'sphere' shape. Params: name, subdivs, size, scene
                var car = new Car(scene);
                /*-----------------------Path------------------------------------------*/
                // Create array of points to describe the curve
                var points = [];
                var n = 450; // number of points
                var r = 50; //radius
                for (var i = 0; i < n + 1; i++) {
                    points.push(new BABYLON.Vector3((r + (r / 5) * Math.sin(8 * i * Math.PI / n)) * Math.sin(2 * i * Math.PI / n), 0, (r + (r / 10) * Math.sin(6 * i * Math.PI / n)) * Math.cos(2 * i * Math.PI / n)));
                }
                points.forEach((p, n) => {
                    if (n % 10 == 0) {
                        if (points[n + 1]) {
                            var x = BABYLON.Vector3.Cross(new BABYLON.Vector3(0, 1, 0), p.subtract(points[n + 1]));
                            x.normalize().scaleInPlace(4);
                            var cube = BABYLON.Mesh.CreateBox("", 0.3, scene);
                            cube.scaling.y = 4;
                            cube.position.copyFrom(p);
                            cube.position.addInPlace(x);
                            var cube = BABYLON.Mesh.CreateBox("", 0.3, scene);
                            cube.scaling.y = 4;
                            cube.position.copyFrom(p);
                            cube.position.subtractInPlace(x);
                        }
                    }
                });
                //Draw the curve
                var track = BABYLON.MeshBuilder.CreateLines('track', { points: points }, scene);
                track.color = new BABYLON.Color3(0, 0, 0);
                /*-----------------------End Path------------------------------------------*/
                /*-----------------------Ground------------------------------------------*/
                var ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 3 * r, height: 3 * r }, scene);
                /*-----------------------End Ground------------------------------------------*/
                var path3d = new BABYLON.Path3D(points);
                var normals = path3d.getNormals();
                var theta = Math.acos(BABYLON.Vector3.Dot(BABYLON.Axis.Z, normals[0]));
                // Keyboard events
                var inputMap = {};
                scene.actionManager = new BABYLON.ActionManager(scene);
                scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger, function (evt) {
                    inputMap[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";
                }));
                scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyUpTrigger, function (evt) {
                    inputMap[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";
                }));
                // Game/Render loop
                scene.onBeforeRenderObservable.add(() => {
                    car.update(inputMap, scene.getEngine().getDeltaTime() / 1000);
                    car.body.computeWorldMatrix(true);
                    car.lights.forEach((l) => {
                        l.computeWorldMatrix(true);
                    });
                    camera.position.copyFrom(car.body.position.subtract(car.body.forward.scale(5)).add(new BABYLON.Vector3(0, 1.6, 0)));
                    camera.setTarget(car.body.position);
                });
                car.lights.forEach((l) => {
                    var trail = new BABYLON.TrailMesh('new', l, scene, .1, 10, true);
                    var sourceMat = new BABYLON.StandardMaterial('sourceMat', scene);
                    sourceMat.emissiveColor =
                        sourceMat.diffuseColor = BABYLON.Color3.Black();
                    sourceMat.specularColor = BABYLON.Color3.Black();
                    trail.material = sourceMat;
                });
                return scene;
            }
        }
        createScene = function() { return Playground.CreateScene(engine, engine.getRenderingCanvas()); }

        engine = createDefaultEngine();
        if (!engine) throw 'engine should not be null.';
scene = createScene();

        engine.runRenderLoop(function () {
            if (scene) {
                scene.render();
            }
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>
</html>
