<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>functionForm</title>

        <!-- Babylon.js -->
        <script src="https://code.jquery.com/pep/0.4.2/pep.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/ammo.js"></script>
        <script src="https://preview.babylonjs.com/cannon.js"></script>
        <script src="https://preview.babylonjs.com/Oimo.js"></script>
        <script src="https://preview.babylonjs.com/libktx.js"></script>
        <script src="https://preview.babylonjs.com/earcut.min.js"></script>
        <script src="https://preview.babylonjs.com/babylon.js"></script>
        <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
        <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        var canvas = document.getElementById("renderCanvas");

        var engine = null;
        var scene = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true }); };

        class DrivingKart {
            constructor() {
                this.power = 20;
                this.speed = new BABYLON.Vector3();
                this.maxSpeed = 30;
                this.turnSpeed = 0;
                this.maxTurnSpeed = 2;
                this.turnAcceleration = 40;
                this.body = BABYLON.Mesh.CreateSphere("kartBody", 16, 1, scene);
                this.body.position.y = 0.5;
                this.body.rotationQuaternion = new BABYLON.Quaternion();
            }
            update(inputMap, deltaTime) {
                if (inputMap["w"] || inputMap["ArrowUp"]) {
                    this.speed.z += this.power * deltaTime;
                }
                if (inputMap["s"] || inputMap["ArrowDown"]) {
                    this.speed.set(0, 0, 0);
                }
                if (inputMap["d"] || inputMap["ArrowRight"]) {
                    this.turnSpeed += this.turnAcceleration * deltaTime;
                    this.body.rotationQuaternion.multiplyInPlace(BABYLON.Quaternion.RotationAxis(new BABYLON.Vector3(0, 1, 0), this.turnSpeed * deltaTime));
                }
                if (inputMap["a"] || inputMap["ArrowLeft"]) {
                    this.turnSpeed -= this.turnAcceleration * deltaTime;
                    this.body.rotationQuaternion.multiplyInPlace(BABYLON.Quaternion.RotationAxis(new BABYLON.Vector3(0, 1, 0), this.turnSpeed * deltaTime));
                }
                if (!(inputMap["d"] || inputMap["ArrowRight"]) && !(inputMap["a"] || inputMap["ArrowLeft"])) {
                    this.turnSpeed = 0;
                }
                if (Math.abs(this.turnSpeed) > this.maxTurnSpeed) {
                    this.turnSpeed = BABYLON.Scalar.Sign(this.turnSpeed) * this.maxTurnSpeed;
                }
                if (this.speed.length() > this.maxSpeed) {
                    this.speed.normalize().scaleInPlace(this.maxSpeed);
                }
                var mat = new BABYLON.Matrix();
                this.body.rotationQuaternion.toRotationMatrix(mat);
                this.body.position.addInPlace(BABYLON.Vector3.TransformCoordinates(this.speed.scale(deltaTime), mat));
            }
        }
        createScene = function() {
          // This creates a basic Babylon Scene object (non-mesh)
          var scene = new BABYLON.Scene(engine);
          // This creates and positions a free camera (non-mesh)
          var camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
          // This targets the camera to scene origin
          camera.setTarget(BABYLON.Vector3.Zero());
          // This attaches the camera to the canvas
          camera.attachControl(canvas, true);
          // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
          var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);
          // Default intensity is 1. Let's dim the light a small amount
          light.intensity = 0.4;
          var light2 = new BABYLON.PointLight("light1", new BABYLON.Vector3(0, 8, 0), scene);
          light2.intensity = 0.1;
          var light3 = new BABYLON.PointLight("light1", new BABYLON.Vector3(0, 8, 20), scene);
          light3.intensity = 0.1;
          var ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 150, height: 150 }, scene);

          // Our built-in 'sphere' shape. Params: name, subdivs, size, scene
          function driveKart() {
            var drivingKart = new DrivingKart();
            // Keyboard events
            var inputMap = {};
            scene.actionManager = new BABYLON.ActionManager(scene);
            scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger, function (evt) {
                inputMap[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";
            }));
            scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyUpTrigger, function (evt) {
                inputMap[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";
            }));
            // Game/Render loop
            scene.onBeforeRenderObservable.add(() => {
                drivingKart.update(inputMap, scene.getEngine().getDeltaTime() / 1000);
                drivingKart.body.computeWorldMatrix(true);
                camera.position.copyFrom(drivingKart.body.position.subtract(drivingKart.body.forward.scale(5)).add(new BABYLON.Vector3(0, 1.6, 0)));
                camera.setTarget(drivingKart.body.position);
            });
          }
          driveKart();
          return scene;
        }

        engine = createDefaultEngine();
        scene = createScene();

        engine.runRenderLoop(function () {
            if (scene) {
                scene.render();
            }
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>
</html>
